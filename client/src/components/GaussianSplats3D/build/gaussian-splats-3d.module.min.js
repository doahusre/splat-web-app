import*as e from"three";import{Ray as t,Plane as n,MathUtils as r,EventDispatcher as o,Vector3 as s,MOUSE as i,TOUCH as a,Quaternion as c,Spherical as l,Vector2 as h}from"three";const d=new e.Vector3,u=new e.Vector3,p=new e.Vector4,m=new e.Vector4,f=new e.Quaternion,y=new e.Quaternion;let g,A;class C{static CenterComponentCount=3;static ScaleComponentCount=3;static RotationComponentCount=4;static ColorComponentCount=4;static CompressionLevels={0:{BytesPerCenter:12,BytesPerScale:12,BytesPerColor:4,BytesPerRotation:16,ScaleRange:1},1:{BytesPerCenter:6,BytesPerScale:6,BytesPerColor:4,BytesPerRotation:8,ScaleRange:32767}};static CovarianceSizeFloats=6;static CovarianceSizeBytes=24;static HeaderSizeBytes=1024;constructor(e){this.headerBufferData=new ArrayBuffer(C.HeaderSizeBytes),this.headerArrayUint8=new Uint8Array(this.headerBufferData),this.headerArrayUint32=new Uint32Array(this.headerBufferData),this.headerArrayFloat32=new Float32Array(this.headerBufferData),this.headerArrayUint8.set(new Uint8Array(e,0,C.HeaderSizeBytes)),this.versionMajor=this.headerArrayUint8[0],this.versionMinor=this.headerArrayUint8[1],this.headerExtraK=this.headerArrayUint8[2],this.compressionLevel=this.headerArrayUint8[3],this.splatCount=this.headerArrayUint32[1],this.bucketSize=this.headerArrayUint32[2],this.bucketCount=this.headerArrayUint32[3],this.bucketBlockSize=this.headerArrayFloat32[4],this.halfBucketBlockSize=this.bucketBlockSize/2,this.bytesPerBucket=this.headerArrayUint32[5],this.compressionScaleRange=this.headerArrayUint32[6]||C.CompressionLevels[this.compressionLevel].ScaleRange,this.compressionScaleFactor=this.halfBucketBlockSize/this.compressionScaleRange;const t=e.byteLength-C.HeaderSizeBytes;this.splatBufferData=new ArrayBuffer(t),new Uint8Array(this.splatBufferData).set(new Uint8Array(e,C.HeaderSizeBytes,t)),this.bytesPerCenter=C.CompressionLevels[this.compressionLevel].BytesPerCenter,this.bytesPerScale=C.CompressionLevels[this.compressionLevel].BytesPerScale,this.bytesPerColor=C.CompressionLevels[this.compressionLevel].BytesPerColor,this.bytesPerRotation=C.CompressionLevels[this.compressionLevel].BytesPerRotation,this.bytesPerSplat=this.bytesPerCenter+this.bytesPerScale+this.bytesPerColor+this.bytesPerRotation,g=this.fbf.bind(this),A=this.tbf.bind(this),this.linkBufferArrays()}linkBufferArrays(){let e=0===this.compressionLevel?Float32Array:Uint16Array;this.centerArray=new e(this.splatBufferData,0,this.splatCount*C.CenterComponentCount),this.scaleArray=new e(this.splatBufferData,this.bytesPerCenter*this.splatCount,this.splatCount*C.ScaleComponentCount),this.colorArray=new Uint8Array(this.splatBufferData,(this.bytesPerCenter+this.bytesPerScale)*this.splatCount,this.splatCount*C.ColorComponentCount),this.rotationArray=new e(this.splatBufferData,(this.bytesPerCenter+this.bytesPerScale+this.bytesPerColor)*this.splatCount,this.splatCount*C.RotationComponentCount),this.bucketsBase=this.splatCount*this.bytesPerSplat}fbf(t){return 0===this.compressionLevel?t:e.DataUtils.fromHalfFloat(t)}tbf(t){return 0===this.compressionLevel?t:e.DataUtils.toHalfFloat(t)}getHeaderBufferData(){return this.headerBufferData}getSplatBufferData(){return this.splatBufferData}getCenter(t,n=new e.Vector3){let r=[0,0,0];const o=t*C.CenterComponentCount;if(this.compressionLevel>0){const e=this.compressionScaleFactor,s=this.compressionScaleRange,i=Math.floor(t/this.bucketSize);r=new Float32Array(this.splatBufferData,this.bucketsBase+i*this.bytesPerBucket,3),n.x=(this.centerArray[o]-s)*e+r[0],n.y=(this.centerArray[o+1]-s)*e+r[1],n.z=(this.centerArray[o+2]-s)*e+r[2]}else n.x=this.centerArray[o],n.y=this.centerArray[o+1],n.z=this.centerArray[o+2];return n}setCenter(e,t){let n=[0,0,0];const r=e*C.CenterComponentCount;if(this.compressionLevel>0){const o=1/this.compressionScaleFactor,s=this.compressionScaleRange,i=2*s+1,a=Math.floor(e/this.bucketSize);n=new Float32Array(this.splatBufferData,this.bucketsBase+a*this.bytesPerBucket,3),this.centerArray[r]=clamp(Math.round((t.x-n[0])*o)+s,0,i),this.centerArray[r+1]=clamp(Math.round((t.y-n[1])*o)+s,0,i),this.centerArray[r+2]=clamp(Math.round((t.z-n[2])*o)+s,0,i)}else this.centerArray[r]=t.x,this.centerArray[r+1]=t.y,this.centerArray[r+2]=t.z}getScale(t,n=new e.Vector3){const r=t*C.ScaleComponentCount;return n.set(g(this.scaleArray[r]),g(this.scaleArray[r+1]),g(this.scaleArray[r+2])),n}setScale(e,t){const n=e*C.ScaleComponentCount;this.scaleArray[n]=A(t.x),this.scaleArray[n+1]=A(t.y),this.scaleArray[n+2]=A(t.z)}getRotation(t,n=new e.Quaternion){const r=t*C.RotationComponentCount;return n.set(g(this.rotationArray[r+1]),g(this.rotationArray[r+2]),g(this.rotationArray[r+3]),g(this.rotationArray[r])),n}setRotation(e,t){const n=e*C.RotationComponentCount;this.rotationArray[n]=A(t.w),this.rotationArray[n+1]=A(t.x),this.rotationArray[n+2]=A(t.y),this.rotationArray[n+3]=A(t.z)}getColor(t,n=new e.Vector4){const r=t*C.ColorComponentCount;return n.set(this.colorArray[r],this.colorArray[r+1],this.colorArray[r+2],this.colorArray[r+3]),n}setColor(e,t){const n=e*C.ColorComponentCount;this.colorArray[n]=t.x,this.colorArray[n+1]=t.y,this.colorArray[n+2]=t.z,this.colorArray[n+3]=t.w}getSplatCount(){return this.splatCount}fillCovarianceArray(t){const n=this.splatCount,r=new e.Vector3,o=new e.Quaternion,s=new e.Matrix3,i=new e.Matrix3,a=new e.Matrix3,c=new e.Matrix4;for(let e=0;e<n;e++){const n=e*C.ScaleComponentCount;r.set(g(this.scaleArray[n]),g(this.scaleArray[n+1]),g(this.scaleArray[n+2])),c.makeScale(r.x,r.y,r.z),i.setFromMatrix4(c);const l=e*C.RotationComponentCount;o.set(g(this.rotationArray[l+1]),g(this.rotationArray[l+2]),g(this.rotationArray[l+3]),g(this.rotationArray[l])),c.makeRotationFromQuaternion(o),s.setFromMatrix4(c),a.copy(s).multiply(i);const h=a.elements;t[C.CovarianceSizeFloats*e]=h[0]*h[0]+h[3]*h[3]+h[6]*h[6],t[C.CovarianceSizeFloats*e+1]=h[0]*h[1]+h[3]*h[4]+h[6]*h[7],t[C.CovarianceSizeFloats*e+2]=h[0]*h[2]+h[3]*h[5]+h[6]*h[8],t[C.CovarianceSizeFloats*e+3]=h[1]*h[1]+h[4]*h[4]+h[7]*h[7],t[C.CovarianceSizeFloats*e+4]=h[1]*h[2]+h[4]*h[5]+h[7]*h[8],t[C.CovarianceSizeFloats*e+5]=h[2]*h[2]+h[5]*h[5]+h[8]*h[8]}}fillCenterArray(e){const t=this.splatCount;let n=[0,0,0];for(let r=0;r<t;r++){const t=r*C.CenterComponentCount;if(this.compressionLevel>0){const o=Math.floor(r/this.bucketSize);n=new Float32Array(this.splatBufferData,this.bucketsBase+o*this.bytesPerBucket,3);const s=this.compressionScaleFactor,i=this.compressionScaleRange;e[t]=(this.centerArray[t]-i)*s+n[0],e[t+1]=(this.centerArray[t+1]-i)*s+n[1],e[t+2]=(this.centerArray[t+2]-i)*s+n[2]}else e[t]=this.centerArray[t],e[t+1]=this.centerArray[t+1],e[t+2]=this.centerArray[t+2]}}fillScaleArray(e){const t=this.fbf.bind(this),n=this.splatCount;for(let r=0;r<n;r++){const n=r*C.ScaleComponentCount;e[n]=t(this.scaleArray[n]),e[n+1]=t(this.scaleArray[n+1]),e[n+2]=t(this.scaleArray[n+2])}}fillRotationArray(e){const t=this.fbf.bind(this),n=this.splatCount;for(let r=0;r<n;r++){const n=r*C.RotationComponentCount;e[n]=t(this.rotationArray[n]),e[n+1]=t(this.rotationArray[n+1]),e[n+2]=t(this.rotationArray[n+2]),e[n+3]=t(this.rotationArray[n+3])}}fillColorArray(e){const t=this.splatCount;for(let n=0;n<t;n++){const t=n*C.ColorComponentCount;e[t]=this.colorArray[t],e[t+1]=this.colorArray[t+1],e[t+2]=this.colorArray[t+2],e[t+3]=this.colorArray[t+3]}}swapVertices(e,t){this.getCenter(e,d),this.getCenter(t,u),this.setCenter(t,d),this.setCenter(e,u),this.getScale(e,d),this.getScale(t,u),this.setScale(t,d),this.setScale(e,u),this.getRotation(e,f),this.getRotation(t,y),this.setRotation(t,f),this.setRotation(e,y),this.getColor(e,p),this.getColor(t,m),this.setColor(t,p),this.setColor(e,m)}}!function(){const e=new Float32Array(1),t=new Int32Array(e.buffer)}();const w=function(){const e=new Float32Array(1),t=new Int32Array(e.buffer);return function(n){return e[0]=n,t[0]}}(),v=function(e,t){return new Promise(((n,r)=>{fetch(e).then((async e=>{const o=e.body.getReader();let s=0,i=e.headers.get("Content-Length"),a=i?parseInt(i):void 0;const c=[];for(;;)try{const{value:e,done:r}=await o.read();if(r){t&&t(100,"100%",e);const r=new Blob(c).arrayBuffer();n(r);break}let i,l;s+=e.length,void 0!==a&&(i=s/a*100,l=`${i.toFixed(2)}%`),c.push(e),t&&t(i,l,e)}catch(e){r(e);break}}))}))},x=function(e,t,n){return Math.max(Math.min(e,n),t)},b=function(){return performance.now()/1e3},M=256;class P{constructor(e){this.plyBuffer=e}decodeHeader(e){const t=new TextDecoder;let n=0,r="";console.log(".PLY size: "+e.byteLength+" bytes");const o=100;for(;;){if(n+o>=e.byteLength)throw new Error("End of file reached while searching for end of header");const s=new Uint8Array(e,n,o);r+=t.decode(s),n+=o;const i=new Uint8Array(e,Math.max(0,n-200),200);if(t.decode(i).includes("end_header"))break}const s=r.split("\n");let i=0,a={};for(let e=0;e<s.length;e++){const t=s[e].trim();if(t.startsWith("element vertex")){const e=t.match(/\d+/);e&&(i=parseInt(e[0]))}else if(t.startsWith("property")){const e=t.match(/(\w+)\s+(\w+)\s+(\w+)/);if(e){const t=e[2];a[e[3]]=t}}else if("end_header"===t)break}const c=r.indexOf("end_header")+10+1;return{splatCount:i,propertyTypes:a,vertexData:new DataView(e,c),headerOffset:n}}readRawVertexFast(e,t,n,r,o,s){let i=s||{};for(let s of r){const r=o[s];"float"===r?i[s]=e.getFloat32(t+n[s],!0):"uchar"===r&&(i[s]=e.getUint8(t+n[s])/255)}}parseToSplatBuffer(t=0,n=1){const r=performance.now();console.log("Parsing PLY to SPLAT...");const{splatCount:o,propertyTypes:s,vertexData:i}=this.decodeHeader(this.plyBuffer);let a=0;for(const e in s)e.startsWith("f_rest_")&&(a+=1);const c=a/3;console.log("Detected degree",0,"with ",c,"coefficients per color");const l=[];for(let e=0;e<3;++e)l.push(`f_dc_${e}`);for(let e=0;e<c;++e)for(let t=0;t<3;++t)l.push(`f_rest_${t*c+e}`);let h=0,d={};const u={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1};for(let e in s)if(s.hasOwnProperty(e)){const t=s[e];d[e]=h,h+=u[t]}let p={};const m=["scale_0","scale_1","scale_2","rot_0","rot_1","rot_2","rot_3","x","y","z","f_dc_0","f_dc_1","f_dc_2","opacity"],f=[],y={};for(let e of m)y[e]=0;f.push(y);for(let e=0;e<o;e++){let t;if(this.readRawVertexFast(i,e*h,d,m,s,p),t=s.opacity?1/(1+Math.exp(-p.opacity))*255:255,t>n){const e={};for(let t of m)e[t]=p[t];f.push(e)}}console.log("Total valid splats: ",f.length,"out of",o);const g=[];for(let e=0;e<f.length;e++)p=f[e],g.push([p.x,p.y,p.z]);const A=this.computeBuckets(g),w=A.length*M,v=C.HeaderSizeBytes,b=new Uint8Array(new ArrayBuffer(v));b[3]=t,new Uint32Array(b.buffer,4,1)[0]=w;let P=C.CompressionLevels[t].BytesPerCenter,S=C.CompressionLevels[t].BytesPerScale,T=C.CompressionLevels[t].BytesPerColor,D=C.CompressionLevels[t].BytesPerRotation;const F=new ArrayBuffer(P*w),R=new ArrayBuffer(S*w),B=new ArrayBuffer(T*w),E=new ArrayBuffer(D*w),I=C.CompressionLevels[t].ScaleRange,k=I/2.5,L=2*I+1,z=new e.Vector3,V=new e.Vector3;let U=0;for(let n=0;n<A.length;n++){const r=A[n];z.fromArray(r.center);for(let n=0;n<r.splats.length;n++){let o=r.splats[n],i=!1;if(0===o&&(i=!0),p=f[o],0===t){const t=new Float32Array(F,U*P,3),n=new Float32Array(R,U*S,3),r=new Float32Array(E,U*D,4);if(s.scale_0){const t=new e.Quaternion(p.rot_1,p.rot_2,p.rot_3,p.rot_0);t.normalize(),r.set([t.w,t.x,t.y,t.z]),n.set([Math.exp(p.scale_0),Math.exp(p.scale_1),Math.exp(p.scale_2)])}else n.set([.01,.01,.01]),r.set([1,0,0,0]);t.set([p.x,p.y,p.z])}else{const t=new Uint16Array(F,U*P,3),n=new Uint16Array(R,U*S,3),r=new Uint16Array(E,U*D,4),o=e.DataUtils.toHalfFloat.bind(e.DataUtils);if(s.scale_0){const t=new e.Quaternion(p.rot_1,p.rot_2,p.rot_3,p.rot_0);t.normalize(),r.set([o(t.w),o(t.x),o(t.y),o(t.z)]),n.set([o(Math.exp(p.scale_0)),o(Math.exp(p.scale_1)),o(Math.exp(p.scale_2))])}else n.set([o(.01),o(.01),o(.01)]),r.set([o(1),0,0,0]);V.set(p.x,p.y,p.z).sub(z),V.x=Math.round(V.x*k)+I,V.x=x(V.x,0,L),V.y=Math.round(V.y*k)+I,V.y=x(V.y,0,L),V.z=Math.round(V.z*k)+I,V.z=x(V.z,0,L),t.set([V.x,V.y,V.z])}const a=new Uint8ClampedArray(B,U*T,4);if(i)a[0]=255,a[1]=0,a[2]=0,a[3]=0;else{if(s.f_dc_0){const e=.28209479177387814;a.set([255*(.5+e*p.f_dc_0),255*(.5+e*p.f_dc_1),255*(.5+e*p.f_dc_2)])}else a.set([255,0,0]);s.opacity?a[3]=1/(1+Math.exp(-p.opacity))*255:a[3]=255}U++}}const _=12*A.length,O=F.byteLength+R.byteLength+B.byteLength+E.byteLength,N=new Uint32Array(b.buffer),j=new Float32Array(b.buffer);let H=v+O;t>0&&(H+=_,N[2]=M,N[3]=A.length,j[4]=5,N[5]=12,N[6]=C.CompressionLevels[t].ScaleRange);const W=new ArrayBuffer(H);if(new Uint8Array(W,0,v).set(b),new Uint8Array(W,v,F.byteLength).set(new Uint8Array(F)),new Uint8Array(W,v+F.byteLength,R.byteLength).set(new Uint8Array(R)),new Uint8Array(W,v+F.byteLength+R.byteLength,B.byteLength).set(new Uint8Array(B)),new Uint8Array(W,v+F.byteLength+R.byteLength+B.byteLength,E.byteLength).set(new Uint8Array(E)),t>0){const e=new Float32Array(W,v+O,3*A.length);for(let t=0;t<A.length;t++){const n=A[t],r=3*t;e[r]=n.center[0],e[r+1]=n.center[1],e[r+2]=n.center[2]}}const Y=new C(W),Q=performance.now();return console.log("Parsing PLY to SPLAT complete!"),console.log("Total time: ",(Q-r).toFixed(2)+" ms"),Y}computeBuckets(t){const n=t.length,r=new e.Vector3,o=new e.Vector3;for(let e=1;e<n;e++){const n=t[e];(0===e||n[0]<r.x)&&(r.x=n[0]),(0===e||n[0]>o.x)&&(o.x=n[0]),(0===e||n[1]<r.y)&&(r.y=n[1]),(0===e||n[1]>o.y)&&(o.y=n[1]),(0===e||n[2]<r.z)&&(r.z=n[2]),(0===e||n[2]>o.z)&&(o.z=n[2])}const s=(new e.Vector3).copy(o).sub(r),i=Math.ceil(s.y/5),a=Math.ceil(s.z/5),c=new e.Vector3,l=[],h={};for(let e=1;e<n;e++){const n=t[e],o=Math.ceil((n[0]-r.x)/5),s=Math.ceil((n[1]-r.y)/5),d=Math.ceil((n[2]-r.z)/5);c.x=5*(o-1)+r.x+2.5,c.y=5*(s-1)+r.y+2.5,c.z=5*(d-1)+r.z+2.5;const u=o*(i*a)+s*a+d;let p=h[u];p||(h[u]=p={splats:[],center:c.toArray()}),p.splats.push(e),p.splats.length>=M&&(l.push(p),h[u]=null)}for(let e in h)if(h.hasOwnProperty(e)){const t=h[e];if(t){for(;t.splats.length<M;)t.splats.push(0);l.push(t)}}return l}}class S{constructor(){this.splatBuffer=null}fetchFile(e,t){return new Promise(((n,r)=>{v(e,t).then((e=>{n(e)})).catch((e=>{r(e)}))}))}loadFromURL(e,t,n=0,r=1){return new Promise(((o,s)=>{this.fetchFile(e,t).then((e=>{const t=new P(e).parseToSplatBuffer(n,r);this.splatBuffer=t,o(t)})).catch((e=>{s(e)}))}))}}class T{constructor(e=null){this.splatBuffer=e,this.downLoadLink=null}loadFromURL(e,t){return new Promise(((n,r)=>{v(e,t).then((e=>{const t=new C(e);n(t)})).catch((e=>{r(e)}))}))}setFromBuffer(e){this.splatBuffer=e}downloadFile(e){const t=new Uint8Array(this.splatBuffer.getHeaderBufferData()),n=new Uint8Array(this.splatBuffer.getSplatBufferData()),r=new Blob([t.buffer,n.buffer],{type:"application/octet-stream"});this.downLoadLink||(this.downLoadLink=document.createElement("a"),document.body.appendChild(this.downLoadLink)),this.downLoadLink.download=e,this.downLoadLink.href=URL.createObjectURL(r),this.downLoadLink.click()}}const D={type:"change"},F={type:"start"},R={type:"end"},B=new t,E=new n,I=Math.cos(70*r.DEG2RAD);class k extends o{constructor(e,t){super(),this.object=e,this.domElement=t,this.domElement.style.touchAction="none",this.enabled=!0,this.target=new s,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"KeyA",UP:"KeyW",RIGHT:"KeyD",BOTTOM:"KeyS"},this.mouseButtons={LEFT:i.ROTATE,MIDDLE:i.DOLLY,RIGHT:i.PAN},this.touches={ONE:a.ROTATE,TWO:a.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this.getPolarAngle=function(){return u.phi},this.getAzimuthalAngle=function(){return u.theta},this.getDistance=function(){return this.object.position.distanceTo(this.target)},this.listenToKeyEvents=function(e){e.addEventListener("keydown",oe),this._domElementKeyEvents=e},this.stopListenToKeyEvents=function(){this._domElementKeyEvents.removeEventListener("keydown",oe),this._domElementKeyEvents=null},this.saveState=function(){n.target0.copy(n.target),n.position0.copy(n.object.position),n.zoom0=n.object.zoom},this.reset=function(){n.target.copy(n.target0),n.object.position.copy(n.position0),n.object.zoom=n.zoom0,n.object.updateProjectionMatrix(),n.dispatchEvent(D),n.update(),o=r.NONE},this.update=function(){const t=new s,i=(new c).setFromUnitVectors(e.up,new s(0,1,0)),a=i.clone().invert(),l=new s,h=new c,y=new s,g=2*Math.PI;return function(){i.setFromUnitVectors(e.up,new s(0,1,0)),a.copy(i).invert();const c=n.object.position;t.copy(c).sub(n.target),t.applyQuaternion(i),u.setFromVector3(t),n.autoRotate&&o===r.NONE&&V(2*Math.PI/60/60*n.autoRotateSpeed),n.enableDamping?(u.theta+=p.theta*n.dampingFactor,u.phi+=p.phi*n.dampingFactor):(u.theta+=p.theta,u.phi+=p.phi);let A=n.minAzimuthAngle,C=n.maxAzimuthAngle;isFinite(A)&&isFinite(C)&&(A<-Math.PI?A+=g:A>Math.PI&&(A-=g),C<-Math.PI?C+=g:C>Math.PI&&(C-=g),u.theta=A<=C?Math.max(A,Math.min(C,u.theta)):u.theta>(A+C)/2?Math.max(A,u.theta):Math.min(C,u.theta)),u.phi=Math.max(n.minPolarAngle,Math.min(n.maxPolarAngle,u.phi)),u.makeSafe(),!0===n.enableDamping?n.target.addScaledVector(f,n.dampingFactor):n.target.add(f),n.zoomToCursor&&T||n.object.isOrthographicCamera?u.radius=Y(u.radius):u.radius=Y(u.radius*m),t.setFromSpherical(u),t.applyQuaternion(a),c.copy(n.target).add(t),n.object.lookAt(n.target),!0===n.enableDamping?(p.theta*=1-n.dampingFactor,p.phi*=1-n.dampingFactor,f.multiplyScalar(1-n.dampingFactor)):(p.set(0,0,0),f.set(0,0,0));let w=!1;if(n.zoomToCursor&&T){let r=null;if(n.object.isPerspectiveCamera){const e=t.length();r=Y(e*m);const o=e-r;n.object.position.addScaledVector(P,o),n.object.updateMatrixWorld()}else if(n.object.isOrthographicCamera){const e=new s(S.x,S.y,0);e.unproject(n.object),n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),w=!0;const o=new s(S.x,S.y,0);o.unproject(n.object),n.object.position.sub(o).add(e),n.object.updateMatrixWorld(),r=t.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),n.zoomToCursor=!1;null!==r&&(this.screenSpacePanning?n.target.set(0,0,-1).transformDirection(n.object.matrix).multiplyScalar(r).add(n.object.position):(B.origin.copy(n.object.position),B.direction.set(0,0,-1).transformDirection(n.object.matrix),Math.abs(n.object.up.dot(B.direction))<I?e.lookAt(n.target):(E.setFromNormalAndCoplanarPoint(n.object.up,n.target),B.intersectPlane(E,n.target))))}else n.object.isOrthographicCamera&&(n.object.zoom=Math.max(n.minZoom,Math.min(n.maxZoom,n.object.zoom/m)),n.object.updateProjectionMatrix(),w=!0);return m=1,T=!1,!!(w||l.distanceToSquared(n.object.position)>d||8*(1-h.dot(n.object.quaternion))>d||y.distanceToSquared(n.target)>0)&&(n.dispatchEvent(D),l.copy(n.object.position),h.copy(n.object.quaternion),y.copy(n.target),w=!1,!0)}}(),this.dispose=function(){n.domElement.removeEventListener("contextmenu",se),n.domElement.removeEventListener("pointerdown",ee),n.domElement.removeEventListener("pointercancel",ne),n.domElement.removeEventListener("wheel",re),n.domElement.removeEventListener("pointermove",te),n.domElement.removeEventListener("pointerup",ne),null!==n._domElementKeyEvents&&(n._domElementKeyEvents.removeEventListener("keydown",oe),n._domElementKeyEvents=null)};const n=this,r={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let o=r.NONE;const d=1e-6,u=new l,p=new l;let m=1;const f=new s,y=new h,g=new h,A=new h,C=new h,w=new h,v=new h,x=new h,b=new h,M=new h,P=new s,S=new h;let T=!1;const k=[],L={};function z(){return Math.pow(.95,n.zoomSpeed)}function V(e){p.theta-=e}function U(e){p.phi-=e}const _=function(){const e=new s;return function(t,n){e.setFromMatrixColumn(n,0),e.multiplyScalar(-t),f.add(e)}}(),O=function(){const e=new s;return function(t,r){!0===n.screenSpacePanning?e.setFromMatrixColumn(r,1):(e.setFromMatrixColumn(r,0),e.crossVectors(n.object.up,e)),e.multiplyScalar(t),f.add(e)}}(),N=function(){const e=new s;return function(t,r){const o=n.domElement;if(n.object.isPerspectiveCamera){const s=n.object.position;e.copy(s).sub(n.target);let i=e.length();i*=Math.tan(n.object.fov/2*Math.PI/180),_(2*t*i/o.clientHeight,n.object.matrix),O(2*r*i/o.clientHeight,n.object.matrix)}else n.object.isOrthographicCamera?(_(t*(n.object.right-n.object.left)/n.object.zoom/o.clientWidth,n.object.matrix),O(r*(n.object.top-n.object.bottom)/n.object.zoom/o.clientHeight,n.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),n.enablePan=!1)}}();function j(e){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?m/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function H(e){n.object.isPerspectiveCamera||n.object.isOrthographicCamera?m*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),n.enableZoom=!1)}function W(t){if(!n.zoomToCursor)return;T=!0;const r=n.domElement.getBoundingClientRect(),o=t.clientX-r.left,s=t.clientY-r.top,i=r.width,a=r.height;S.x=o/i*2-1,S.y=-s/a*2+1,P.set(S.x,S.y,1).unproject(e).sub(e.position).normalize()}function Y(e){return Math.max(n.minDistance,Math.min(n.maxDistance,e))}function Q(e){y.set(e.clientX,e.clientY)}function G(e){C.set(e.clientX,e.clientY)}function K(){if(1===k.length)y.set(k[0].pageX,k[0].pageY);else{const e=.5*(k[0].pageX+k[1].pageX),t=.5*(k[0].pageY+k[1].pageY);y.set(e,t)}}function X(){if(1===k.length)C.set(k[0].pageX,k[0].pageY);else{const e=.5*(k[0].pageX+k[1].pageX),t=.5*(k[0].pageY+k[1].pageY);C.set(e,t)}}function $(){const e=k[0].pageX-k[1].pageX,t=k[0].pageY-k[1].pageY,n=Math.sqrt(e*e+t*t);x.set(0,n)}function Z(e){if(1==k.length)g.set(e.pageX,e.pageY);else{const t=ae(e),n=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);g.set(n,r)}A.subVectors(g,y).multiplyScalar(n.rotateSpeed);const t=n.domElement;V(2*Math.PI*A.x/t.clientHeight),U(2*Math.PI*A.y/t.clientHeight),y.copy(g)}function q(e){if(1===k.length)w.set(e.pageX,e.pageY);else{const t=ae(e),n=.5*(e.pageX+t.x),r=.5*(e.pageY+t.y);w.set(n,r)}v.subVectors(w,C).multiplyScalar(n.panSpeed),N(v.x,v.y),C.copy(w)}function J(e){const t=ae(e),r=e.pageX-t.x,o=e.pageY-t.y,s=Math.sqrt(r*r+o*o);b.set(0,s),M.set(0,Math.pow(b.y/x.y,n.zoomSpeed)),j(M.y),x.copy(b)}function ee(e){!1!==n.enabled&&(0===k.length&&(n.domElement.setPointerCapture(e.pointerId),n.domElement.addEventListener("pointermove",te),n.domElement.addEventListener("pointerup",ne)),function(e){k.push(e)}(e),"touch"===e.pointerType?function(e){switch(ie(e),k.length){case 1:switch(n.touches.ONE){case a.ROTATE:if(!1===n.enableRotate)return;K(),o=r.TOUCH_ROTATE;break;case a.PAN:if(!1===n.enablePan)return;X(),o=r.TOUCH_PAN;break;default:o=r.NONE}break;case 2:switch(n.touches.TWO){case a.DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;n.enableZoom&&$(),n.enablePan&&X(),o=r.TOUCH_DOLLY_PAN;break;case a.DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;n.enableZoom&&$(),n.enableRotate&&K(),o=r.TOUCH_DOLLY_ROTATE;break;default:o=r.NONE}break;default:o=r.NONE}o!==r.NONE&&n.dispatchEvent(F)}(e):function(e){let t;switch(e.button){case 0:t=n.mouseButtons.LEFT;break;case 1:t=n.mouseButtons.MIDDLE;break;case 2:t=n.mouseButtons.RIGHT;break;default:t=-1}switch(t){case i.DOLLY:if(!1===n.enableZoom)return;!function(e){W(e),x.set(e.clientX,e.clientY)}(e),o=r.DOLLY;break;case i.ROTATE:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enablePan)return;G(e),o=r.PAN}else{if(!1===n.enableRotate)return;Q(e),o=r.ROTATE}break;case i.PAN:if(e.ctrlKey||e.metaKey||e.shiftKey){if(!1===n.enableRotate)return;Q(e),o=r.ROTATE}else{if(!1===n.enablePan)return;G(e),o=r.PAN}break;default:o=r.NONE}o!==r.NONE&&n.dispatchEvent(F)}(e))}function te(e){!1!==n.enabled&&("touch"===e.pointerType?function(e){switch(ie(e),o){case r.TOUCH_ROTATE:if(!1===n.enableRotate)return;Z(e),n.update();break;case r.TOUCH_PAN:if(!1===n.enablePan)return;q(e),n.update();break;case r.TOUCH_DOLLY_PAN:if(!1===n.enableZoom&&!1===n.enablePan)return;!function(e){n.enableZoom&&J(e),n.enablePan&&q(e)}(e),n.update();break;case r.TOUCH_DOLLY_ROTATE:if(!1===n.enableZoom&&!1===n.enableRotate)return;!function(e){n.enableZoom&&J(e),n.enableRotate&&Z(e)}(e),n.update();break;default:o=r.NONE}}(e):function(e){switch(o){case r.ROTATE:if(!1===n.enableRotate)return;!function(e){g.set(e.clientX,e.clientY),A.subVectors(g,y).multiplyScalar(n.rotateSpeed);const t=n.domElement;V(2*Math.PI*A.x/t.clientHeight),U(2*Math.PI*A.y/t.clientHeight),y.copy(g),n.update()}(e);break;case r.DOLLY:if(!1===n.enableZoom)return;!function(e){b.set(e.clientX,e.clientY),M.subVectors(b,x),M.y>0?j(z()):M.y<0&&H(z()),x.copy(b),n.update()}(e);break;case r.PAN:if(!1===n.enablePan)return;!function(e){w.set(e.clientX,e.clientY),v.subVectors(w,C).multiplyScalar(n.panSpeed),N(v.x,v.y),C.copy(w),n.update()}(e)}}(e))}function ne(e){!function(e){delete L[e.pointerId];for(let t=0;t<k.length;t++)if(k[t].pointerId==e.pointerId)return void k.splice(t,1)}(e),0===k.length&&(n.domElement.releasePointerCapture(e.pointerId),n.domElement.removeEventListener("pointermove",te),n.domElement.removeEventListener("pointerup",ne)),n.dispatchEvent(R),o=r.NONE}function re(e){!1!==n.enabled&&!1!==n.enableZoom&&o===r.NONE&&(e.preventDefault(),n.dispatchEvent(F),function(e){W(e),e.deltaY<0?H(z()):e.deltaY>0&&j(z()),n.update()}(e),n.dispatchEvent(R))}function oe(e){!1!==n.enabled&&!1!==n.enablePan&&function(e){let t=!1;switch(e.code){case n.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?U(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):N(0,n.keyPanSpeed),t=!0;break;case n.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?U(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):N(0,-n.keyPanSpeed),t=!0;break;case n.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?V(2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):N(n.keyPanSpeed,0),t=!0;break;case n.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?V(-2*Math.PI*n.rotateSpeed/n.domElement.clientHeight):N(-n.keyPanSpeed,0),t=!0}t&&(e.preventDefault(),n.update())}(e)}function se(e){!1!==n.enabled&&e.preventDefault()}function ie(e){let t=L[e.pointerId];void 0===t&&(t=new h,L[e.pointerId]=t),t.set(e.pageX,e.pageY)}function ae(e){const t=e.pointerId===k[0].pointerId?k[1]:k[0];return L[t.pointerId]}n.domElement.addEventListener("contextmenu",se),n.domElement.addEventListener("pointerdown",ee),n.domElement.addEventListener("pointercancel",ne),n.domElement.addEventListener("wheel",re,{passive:!1}),this.update()}}class L{constructor(e,t){this.message=e||"Loading...",this.container=t||document.body,this.spinnerDivContainer=document.createElement("div"),this.spinnerDiv=document.createElement("div"),this.messageDiv=document.createElement("div"),this.spinnerDivContainer.className="loaderContainer",this.spinnerDiv.className="loader",this.spinnerDivContainer.style.display="none",this.messageDiv.className="message",this.messageDiv.innerHTML=this.message,this.spinnerDivContainer.appendChild(this.spinnerDiv),this.spinnerDivContainer.appendChild(this.messageDiv),this.container.appendChild(this.spinnerDivContainer);const n=document.createElement("style");n.innerHTML="\n\n            .message {\n                font-family: arial;\n                font-size: 12pt;\n                color: #ffffff;\n                text-align: center;\n                padding-top:15px;\n                width: 180px;\n            }\n\n            .loaderContainer {\n                position: absolute;\n                top: 50%;\n                left: 50%;\n                transform: translate(-80px, -80px);\n                width: 180px;\n            }\n\n            .loader {\n                width: 120px;        /* the size */\n                padding: 15px;       /* the border thickness */\n                background: #07e8d6; /* the color */\n                z-index:99999;\n            \n                aspect-ratio: 1;\n                border-radius: 50%;\n                --_m: \n                    conic-gradient(#0000,#000),\n                    linear-gradient(#000 0 0) content-box;\n                -webkit-mask: var(--_m);\n                    mask: var(--_m);\n                -webkit-mask-composite: source-out;\n                    mask-composite: subtract;\n                box-sizing: border-box;\n                animation: load 1s linear infinite;\n                margin-left: 30px;\n            }\n            \n            @keyframes load {\n                to{transform: rotate(1turn)}\n            }\n\n        ",this.spinnerDivContainer.appendChild(n)}show(){this.spinnerDivContainer.style.display="block"}hide(){this.spinnerDivContainer.style.display="none"}setMessage(e){this.messageDiv.innerHTML=e}}class z extends e.Object3D{constructor(t=new e.Vector3(0,0,1),n=new e.Vector3(0,0,0),r=1,o=.1,s=16776960,i=.2*r,a=.2*i){super(),this.type="ArrowHelper";const c=new e.CylinderGeometry(o,o,r,32);c.translate(0,r/2,0);const l=new e.CylinderGeometry(0,a,i,32);l.translate(0,r,0),this.position.copy(n),this.line=new e.Mesh(c,new e.MeshBasicMaterial({color:s,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new e.Mesh(l,new e.MeshBasicMaterial({color:s,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(t)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{_axis.set(e.z,0,-e.x).normalize();const t=Math.acos(e.y);this.quaternion.setFromAxisAngle(_axis,t)}}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class V{constructor(e){this.scene=e,this.splatRenderTarget=null,this.renderTargetCopyMaterial=null,this.renderTargetCopyQuad=null,this.renderTargetCopyCamera=null,this.meshCursor=null,this.focusMarker=null,this.controlPlane=null}updateSplatRenderTargetForRenderDimensions(t,n){this.splatRenderTarget=new e.WebGLRenderTarget(t,n,{format:e.RGBAFormat,stencilBuffer:!1,depthBuffer:!0}),this.splatRenderTarget.depthTexture=new e.DepthTexture(t,n),this.splatRenderTarget.depthTexture.format=e.DepthFormat,this.splatRenderTarget.depthTexture.type=e.UnsignedIntType}setupRenderTargetCopyObjects(){this.renderTargetCopyMaterial=new e.ShaderMaterial({vertexShader:"\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = vec4( position.xy, 0.0, 1.0 );    \n                }\n            ",fragmentShader:"\n                #include <common>\n                #include <packing>\n                varying vec2 vUv;\n                uniform sampler2D sourceColorTexture;\n                uniform sampler2D sourceDepthTexture;\n                void main() {\n                    vec4 color = texture2D(sourceColorTexture, vUv);\n                    float fragDepth = texture2D(sourceDepthTexture, vUv).x;\n                    gl_FragDepth = fragDepth;\n                    gl_FragColor = vec4(color.rgb, color.a * 2.0);\n              }\n            ",uniforms:{sourceColorTexture:{type:"t",value:null},sourceDepthTexture:{type:"t",value:null}},depthWrite:!1,depthTest:!1,transparent:!0,blending:e.CustomBlending,blendSrc:e.SrcAlphaFactor,blendSrcAlpha:e.SrcAlphaFactor,blendDst:e.OneMinusSrcAlphaFactor,blendDstAlpha:e.OneMinusSrcAlphaFactor}),this.renderTargetCopyMaterial.extensions.fragDepth=!0,this.renderTargetCopyQuad=new e.Mesh(new e.PlaneGeometry(2,2),this.renderTargetCopyMaterial),this.renderTargetCopyCamera=new e.OrthographicCamera(-1,1,1,-1,0,1)}setupMeshCursor(){if(!this.meshCursor){const t=new e.ConeGeometry(.5,1.5,32),n=new e.MeshBasicMaterial({color:16777215}),r=new e.Mesh(t,n);r.rotation.set(0,0,Math.PI),r.position.set(0,1,0);const o=new e.Mesh(t,n);o.position.set(0,-1,0);const s=new e.Mesh(t,n);s.rotation.set(0,0,Math.PI/2),s.position.set(1,0,0);const i=new e.Mesh(t,n);i.rotation.set(0,0,-Math.PI/2),i.position.set(-1,0,0),this.meshCursor=new e.Object3D,this.meshCursor.add(r),this.meshCursor.add(o),this.meshCursor.add(s),this.meshCursor.add(i),this.meshCursor.scale.set(.1,.1,.1),this.scene.add(this.meshCursor),this.meshCursor.visible=!1}}destroyMeshCursor(){this.meshCursor&&(this.meshCursor.children.forEach((e=>{e.geometry.dispose(),e.material.dispose()})),this.scene.remove(this.meshCursor),this.meshCursor=null)}setMeshCursorVisibility(e){this.meshCursor.visible=e}setMeshCursorPosition(e){this.meshCursor.position.copy(e)}positionAndOrientMeshCursor(e,t){this.meshCursor.position.copy(e),this.meshCursor.up.copy(t.up),this.meshCursor.lookAt(t.position)}setupFocusMarker(){if(!this.focusMarker){const t=new e.SphereGeometry(.5,32,32),n=V.buildFocusMarkerMaterial();n.depthTest=!1,n.depthWrite=!1,n.transparent=!0;const r=new e.Mesh(t,n);this.focusMarker=r}}updateFocusMarker=function(){const t=new e.Vector3,n=new e.Matrix4;return function(e,r,o){n.copy(r.matrixWorld).invert(),t.copy(e).applyMatrix4(n),t.normalize().multiplyScalar(10),t.applyMatrix4(r.matrixWorld),this.focusMarker.position.copy(t),this.focusMarker.material.uniforms.realFocusPosition.value.copy(e),this.focusMarker.material.uniforms.viewport.value.copy(o),this.focusMarker.material.uniformsNeedUpdate=!0}}();setFocusMarkerVisibility(e){this.focusMarker.visible=e}setFocusMarkerOpacity(e){this.focusMarker.material.uniforms.opacity.value=e,this.focusMarker.material.uniformsNeedUpdate=!0}getFocusMarkerOpacity(){return this.focusMarker.material.uniforms.opacity.value}setupControlPlane(){const t=new e.PlaneGeometry(1,1);t.rotateX(-Math.PI/2);const n=new e.MeshBasicMaterial({color:16777215});n.transparent=!0,n.opacity=.6,n.depthTest=!1,n.depthWrite=!1,n.side=e.DoubleSide;const r=new e.Mesh(t,n),o=new e.Vector3(0,1,0);o.normalize();const s=new e.Vector3(0,0,0),i=new z(o,s,.5,.01,56576,.1,.03);this.controlPlane=new e.Object3D,this.controlPlane.add(r),this.controlPlane.add(i)}setControlPlaneVisibility(e){this.controlPlane.visible=e}positionAndOrientControlPlane=function(){const t=new e.Quaternion,n=new e.Vector3(0,1,0);return function(e,r){t.setFromUnitVectors(n,r),this.controlPlane.position.copy(e),this.controlPlane.quaternion.copy(t)}}();addDebugMeshes(){this.debugRoot=this.createDebugMeshes(),this.secondaryDebugRoot=this.createSecondaryDebugMeshes(),this.scene.add(this.debugRoot),this.scene.add(this.secondaryDebugRoot)}createDebugMeshes(t){const n=new e.SphereGeometry(1,32,32),r=new e.Object3D,o=(o,s)=>{let i=new e.Mesh(n,V.buildDebugMaterial(o));i.renderOrder=t,r.add(i),i.position.fromArray(s)};return o(16711680,[-50,0,0]),o(16711680,[50,0,0]),o(65280,[0,0,-50]),o(65280,[0,0,50]),o(16755200,[5,0,5]),r}createSecondaryDebugMeshes(t){const n=new e.BoxGeometry(3,3,3),r=new e.Object3D;const o=o=>{let s=new e.Mesh(n,V.buildDebugMaterial(12303291));s.renderOrder=t,r.add(s),s.position.fromArray(o)};let s=10;return o([-10,0,-10]),o([-10,0,s]),o([s,0,-10]),o([s,0,s]),r}static buildDebugMaterial(t){const n={color:{type:"v3",value:new e.Color(t)}},r=new e.ShaderMaterial({uniforms:n,vertexShader:"\n            #include <common>\n            varying float ndcDepth;\n\n            void main() {\n                gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position.xyz, 1.0);\n                ndcDepth = gl_Position.z / gl_Position.w;\n                gl_Position.x = gl_Position.x / gl_Position.w;\n                gl_Position.y = gl_Position.y / gl_Position.w;\n                gl_Position.z = 0.0;\n                gl_Position.w = 1.0;\n    \n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            varying float ndcDepth;\n            void main() {\n                gl_FragDepth = (ndcDepth + 1.0) / 2.0;\n                gl_FragColor = vec4(color.rgb, 0.0);\n            }\n        ",transparent:!1,depthTest:!0,depthWrite:!0,side:e.FrontSide});return r.extensions.fragDepth=!0,r}static buildFocusMarkerMaterial(t){const n={color:{type:"v3",value:new e.Color(t)},realFocusPosition:{type:"v3",value:new e.Vector3},viewport:{type:"v2",value:new e.Vector2},opacity:{value:0}};return new e.ShaderMaterial({uniforms:n,vertexShader:"\n            #include <common>\n\n            uniform vec2 viewport;\n            uniform vec3 realFocusPosition;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                float radius = 0.01;\n\n                vec4 viewPosition = modelViewMatrix * vec4(position.xyz, 1.0);\n                vec4 viewCenter = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\n\n                vec4 viewFocusPosition = modelViewMatrix * vec4(realFocusPosition, 1.0);\n\n                ndcPosition = projectionMatrix * viewPosition;\n                ndcPosition = ndcPosition * vec4(1.0 / ndcPosition.w);\n                ndcCenter = projectionMatrix * viewCenter;\n                ndcCenter = ndcCenter * vec4(1.0 / ndcCenter.w);\n\n                ndcFocusPosition = projectionMatrix * viewFocusPosition;\n                ndcFocusPosition = ndcFocusPosition * vec4(1.0 / ndcFocusPosition.w);\n\n                gl_Position = projectionMatrix * viewPosition;\n\n            }\n        ",fragmentShader:"\n            #include <common>\n            uniform vec3 color;\n            uniform vec2 viewport;\n            uniform float opacity;\n\n            varying vec4 ndcPosition;\n            varying vec4 ndcCenter;\n            varying vec4 ndcFocusPosition;\n\n            void main() {\n                vec2 screenPosition = vec2(ndcPosition) * viewport;\n                vec2 screenCenter = vec2(ndcCenter) * viewport;\n\n                vec2 screenVec = screenPosition - screenCenter;\n\n                float projectedRadius = length(screenVec);\n\n                float lineWidth = 0.0005 * viewport.y;\n                float aaRange = 0.0025 * viewport.y;\n                float radius = 0.06 * viewport.y;\n                float radDiff = abs(projectedRadius - radius) - lineWidth;\n                float alpha = 1.0 - clamp(radDiff / 5.0, 0.0, 1.0); \n\n                gl_FragColor = vec4(color.rgb, alpha * opacity);\n            }\n        ",transparent:!0,depthTest:!1,depthWrite:!1,side:e.FrontSide})}}const U=new e.Vector3(1,0,0),_=new e.Vector3(0,1,0),O=new e.Vector3(0,0,1);class N{constructor(t=new e.Vector3,n=new e.Vector3){this.origin=new e.Vector3,this.direction=new e.Vector3,this.setParameters(t,n)}setParameters(e,t){this.origin.copy(e),this.direction.copy(t).normalize()}boxContainsPoint(e,t,n){return!(t.x<e.min.x-n||t.x>e.max.x+n||t.y<e.min.y-n||t.y>e.max.y+n||t.z<e.min.z-n||t.z>e.max.z+n)}intersectBox=function(){const t=new e.Vector3,n=[],r=[],o=[];return function(e,s){if(r[0]=this.origin.x,r[1]=this.origin.y,r[2]=this.origin.z,o[0]=this.direction.x,o[1]=this.direction.y,o[2]=this.direction.z,this.boxContainsPoint(e,this.origin,1e-4))return s&&(s.origin.copy(this.origin),s.normal.set(0,0,0),s.distance=-1),!0;for(let i=0;i<3;i++){if(0==o[i])continue;const a=0==i?U:1==i?_:O,c=o[i]<0?e.max:e.min;let l=-Math.sign(o[i]);n[0]=0==i?c.x:1==i?c.y:c.z;let h=n[0]-r[i];if(h*l<0){const c=(i+1)%3,d=(i+2)%3;if(n[2]=o[c]/o[i]*h+r[c],n[1]=o[d]/o[i]*h+r[d],t.set(n[i],n[d],n[c]),this.boxContainsPoint(e,t,1e-4))return s&&(s.origin.copy(t),s.normal.copy(a).multiplyScalar(l),s.distance=t.sub(this.origin).length()),!0}}return!1}}();intersectSphere=function(){const t=new e.Vector3;return function(e,n,r){t.copy(e).sub(this.origin);const o=t.dot(this.direction),s=o*o,i=t.dot(t)-s,a=n*n;if(i>a)return!1;const c=Math.sqrt(a-i),l=o-c,h=o+c;if(h<0)return!1;let d=l<0?h:l;return r&&(r.origin.copy(this.origin).addScaledVector(this.direction,d),r.normal.copy(r.origin).sub(e).normalize(),r.distance=d),!0}}()}class j{constructor(){this.origin=new e.Vector3,this.normal=new e.Vector3,this.distance=0}set(e,t,n){this.origin.copy(e),this.normal.copy(t),this.distance=n}clone(){const e=new j;return e.origin.copy(this.origin),e.normal.copy(this.normal),e.distance=this.distance,e}}class H{constructor(e,t){this.ray=new N(e,t)}setFromCameraAndScreenPosition=function(){const t=new e.Vector2;return function(e,n,r){if(t.x=n.x/r.x*2-1,t.y=(r.y-n.y)/r.y*2-1,e.isPerspectiveCamera)this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(e).sub(this.ray.origin).normalize(),this.camera=e;else{if(!e.isOrthographicCamera)throw new Error("Raycaster::setFromCameraAndScreenPosition() -> Unsupported camera type");this.ray.origin.set(n.x,n.y,(e.near+e.far)/(e.near-e.far)).unproject(e),this.ray.direction.set(0,0,-1).transformDirection(e.matrixWorld),this.camera=e}}}();intersectSplatMesh=function(){const t=new e.Matrix4,n=new e.Matrix4,r=new N;return function(e,o=[]){n.copy(e.matrixWorld),t.copy(n).invert(),r.origin.copy(this.ray.origin).applyMatrix4(t),r.direction.copy(this.ray.direction).transformDirection(t);const s=e.getSplatTree();return s.rootNode&&this.castRayAtSplatTreeNode(r,s,s.rootNode,o),o.sort(((e,t)=>e.distance>t.distance?1:-1)),o.forEach((e=>{e.origin.applyMatrix4(n),e.normal.transformDirection(n)})),o}}();castRayAtSplatTreeNode=function(){const t=new e.Vector3,n=new e.Vector3,r=new e.Quaternion,o=new j,s=1e-7;return function(e,i,a,c=[]){if(e.intersectBox(a.boundingBox)){if(a.data.indexes&&a.data.indexes.length>0)for(let l=0;l<a.data.indexes.length;l++){const h=a.data.indexes[l];if(i.splatBuffer.getCenter(h,t),i.splatBuffer.getRotation(h,r),i.splatBuffer.getScale(h,n),n.x<=s||n.y<=s||n.z<=s)continue;const d=(n.x+n.y+n.z)/3;e.intersectSphere(t,d,o)&&c.push(o.clone())}if(a.children&&a.children.length>0)for(let t of a.children)this.castRayAtSplatTreeNode(e,i,t,c);return c}}}()}let W=0;class Y{constructor(t,n,r,o){this.min=(new e.Vector3).copy(t),this.max=(new e.Vector3).copy(n),this.boundingBox=new e.Box3(this.min,this.max),this.center=(new e.Vector3).copy(this.max).sub(this.min).multiplyScalar(.5).add(this.min),this.depth=r,this.children=[],this.data=null,this.id=o||W++}}class Q{constructor(t,n){this.maxDepth=t,this.maxCentersPerNode=n,this.splatBuffer=null,this.sceneDimensions=new e.Vector3,this.sceneMin=new e.Vector3,this.sceneMax=new e.Vector3,this.rootNode=null,this.addedIndexes={},this.nodesWithIndexes=[]}processSplatBuffer(t,n=(()=>!0)){this.splatBuffer=t,this.addedIndexes={},this.nodesWithIndexes=[];const r=t.getSplatCount(),o=new e.Vector3;for(let e=0;e<r;e++)n(e)&&(t.getCenter(e,o),(0===e||o.x<this.sceneMin.x)&&(this.sceneMin.x=o.x),(0===e||o.x>this.sceneMax.x)&&(this.sceneMax.x=o.x),(0===e||o.y<this.sceneMin.y)&&(this.sceneMin.y=o.y),(0===e||o.y>this.sceneMax.y)&&(this.sceneMax.y=o.y),(0===e||o.z<this.sceneMin.z)&&(this.sceneMin.z=o.z),(0===e||o.z>this.sceneMax.z)&&(this.sceneMax.z=o.z));this.sceneDimensions.copy(this.sceneMin).sub(this.sceneMin);const s=[];for(let e=0;e<r;e++)n(e)&&s.push(e);this.rootNode=new Y(this.sceneMin,this.sceneMax,0),this.rootNode.data={indexes:s},this.processNode(this.rootNode,t)}processNode(t,n){const r=t.data.indexes.length;if(r<this.maxCentersPerNode||t.depth>this.maxDepth){const e=[];for(let n=0;n<t.data.indexes.length;n++)this.addedIndexes[t.data.indexes[n]]||(e.push(t.data.indexes[n]),this.addedIndexes[t.data.indexes[n]]=!0);return t.data.indexes=e,void this.nodesWithIndexes.push(t)}const o=(new e.Vector3).copy(t.max).sub(t.min),s=(new e.Vector3).copy(o).multiplyScalar(.5),i=(new e.Vector3).copy(t.min).add(s),a=[new e.Box3(new e.Vector3(i.x-s.x,i.y,i.z-s.z),new e.Vector3(i.x,i.y+s.y,i.z)),new e.Box3(new e.Vector3(i.x,i.y,i.z-s.z),new e.Vector3(i.x+s.x,i.y+s.y,i.z)),new e.Box3(new e.Vector3(i.x,i.y,i.z),new e.Vector3(i.x+s.x,i.y+s.y,i.z+s.z)),new e.Box3(new e.Vector3(i.x-s.x,i.y,i.z),new e.Vector3(i.x,i.y+s.y,i.z+s.z)),new e.Box3(new e.Vector3(i.x-s.x,i.y-s.y,i.z-s.z),new e.Vector3(i.x,i.y,i.z)),new e.Box3(new e.Vector3(i.x,i.y-s.y,i.z-s.z),new e.Vector3(i.x+s.x,i.y,i.z)),new e.Box3(new e.Vector3(i.x,i.y-s.y,i.z),new e.Vector3(i.x+s.x,i.y,i.z+s.z)),new e.Box3(new e.Vector3(i.x-s.x,i.y-s.y,i.z),new e.Vector3(i.x,i.y,i.z+s.z))],c=[],l=[];for(let e=0;e<a.length;e++)c[e]=0,l[e]=[];const h=new e.Vector3;for(let e=0;e<r;e++){const r=t.data.indexes[e];n.getCenter(r,h);for(let e=0;e<a.length;e++)a[e].containsPoint(h)&&(c[e]++,l[e].push(r))}for(let e=0;e<a.length;e++){const n=new Y(a[e].min,a[e].max,t.depth+1);n.data={indexes:l[e]},t.children.push(n)}t.data={};for(let e of t.children)this.processNode(e,n)}countLeaves(){let e=0;return this.visitLeaves((()=>{e++})),e}visitLeaves(e){const t=(e,n)=>{0===e.children.length&&n(e);for(let r of e.children)t(r,n)};return t(this.rootNode,e)}}class G extends e.Mesh{static buildMesh(e,t,n=1,r=!1,o=1,s=!0){const i=G.buildGeomtery(e),a=G.buildMaterial();return new G(e,i,a,t,n,r,o,s)}constructor(e,t,n,r,o=1,s=!1,i=1,a=!0){super(t,n),this.splatBuffer=e,this.geometry=t,this.material=n,this.renderer=r,this.splatTree=null,this.splatDataTextures=null,this.splatAlphaRemovalThreshold=o,this.halfPrecisionCovariancesOnGPU=s,this.devicePixelRatio=i,this.enableDistancesComputationOnGPU=a,this.buildSplatTree(),this.enableDistancesComputationOnGPU&&(this.distancesTransformFeedback={id:null,program:null,centersBuffer:null,outDistancesBuffer:null,centersLoc:-1,viewProjLoc:-1},this.setupDistancesTransformFeedback()),this.resetLocalSplatDataAndTexturesFromSplatBuffer()}static buildMaterial(){const t={covariancesTexture:{type:"t",value:null},centersColorsTexture:{type:"t",value:null},focal:{type:"v2",value:new e.Vector2},viewport:{type:"v2",value:new e.Vector2},basisViewport:{type:"v2",value:new e.Vector2},debugColor:{type:"v3",value:new e.Color},covariancesTextureSize:{type:"v2",value:new e.Vector2(1024,1024)},centersColorsTextureSize:{type:"v2",value:new e.Vector2(1024,1024)}};return new e.ShaderMaterial({uniforms:t,vertexShader:"\n            precision highp float;\n            #include <common>\n\n            attribute uint splatIndex;\n\n            uniform highp sampler2D covariancesTexture;\n            uniform highp usampler2D centersColorsTexture;\n            uniform vec2 focal;\n            uniform vec2 viewport;\n            uniform vec2 basisViewport;\n            uniform vec2 covariancesTextureSize;\n            uniform vec2 centersColorsTextureSize;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            const vec4 encodeNorm4 = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n            const uvec4 mask4 = uvec4(uint(0x000000FF), uint(0x0000FF00), uint(0x00FF0000), uint(0xFF000000));\n            const uvec4 shift4 = uvec4(0, 8, 16, 24);\n            vec4 uintToRGBAVec (uint u) {\n               uvec4 urgba = mask4 & u;\n               urgba = urgba >> shift4;\n               vec4 rgba = vec4(urgba) * encodeNorm4;\n               return rgba;\n            }\n\n            vec2 getDataUV(in int stride, in int offset, in vec2 dimensions) {\n                vec2 samplerUV = vec2(0.0, 0.0);\n                float d = float(splatIndex * uint(stride) + uint(offset)) / dimensions.x;\n                samplerUV.y = float(floor(d)) / dimensions.y;\n                samplerUV.x = fract(d);\n                return samplerUV;\n            }\n\n            void main () {\n                uvec4 sampledCenterColor = texture(centersColorsTexture, getDataUV(1, 0, centersColorsTextureSize));\n                vec3 splatCenter = uintBitsToFloat(uvec3(sampledCenterColor.gba));\n                vColor = uintToRGBAVec(sampledCenterColor.r);\n\n                vPosition = position.xy * 2.0;\n\n                vec4 viewCenter = modelViewMatrix * vec4(splatCenter, 1.0);\n                vec4 clipCenter = projectionMatrix * viewCenter;\n\n                vec2 sampledCovarianceA = texture(covariancesTexture, getDataUV(3, 0, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceB = texture(covariancesTexture, getDataUV(3, 1, covariancesTextureSize)).rg;\n                vec2 sampledCovarianceC = texture(covariancesTexture, getDataUV(3, 2, covariancesTextureSize)).rg;\n\n                vec3 cov3D_M11_M12_M13 = vec3(sampledCovarianceA.rg, sampledCovarianceB.r);\n                vec3 cov3D_M22_M23_M33 = vec3(sampledCovarianceB.g, sampledCovarianceC.rg);\n\n                // Compute the 2D covariance matrix from the upper-right portion of the 3D covariance matrix\n                mat3 Vrk = mat3(\n                    cov3D_M11_M12_M13.x, cov3D_M11_M12_M13.y, cov3D_M11_M12_M13.z,\n                    cov3D_M11_M12_M13.y, cov3D_M22_M23_M33.x, cov3D_M22_M23_M33.y,\n                    cov3D_M11_M12_M13.z, cov3D_M22_M23_M33.y, cov3D_M22_M23_M33.z\n                );\n                float s = 1.0 / (viewCenter.z * viewCenter.z);\n                mat3 J = mat3(\n                    focal.x / viewCenter.z, 0., -(focal.x * viewCenter.x) * s,\n                    0., focal.y / viewCenter.z, -(focal.y * viewCenter.y) * s,\n                    0., 0., 0.\n                );\n                mat3 W = transpose(mat3(modelViewMatrix));\n                mat3 T = W * J;\n                mat3 cov2Dm = transpose(T) * Vrk * T;\n                cov2Dm[0][0] += 0.3;\n                cov2Dm[1][1] += 0.3;\n\n                // We are interested in the upper-left 2x2 portion of the projected 3D covariance matrix because\n                // we only care about the X and Y values. We want the X-diagonal, cov2Dm[0][0],\n                // the Y-diagonal, cov2Dm[1][1], and the correlation between the two cov2Dm[0][1]. We don't\n                // need cov2Dm[1][0] because it is a symetric matrix.\n                vec3 cov2Dv = vec3(cov2Dm[0][0], cov2Dm[0][1], cov2Dm[1][1]);\n\n                vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n                // We now need to solve for the eigen-values and eigen vectors of the 2D covariance matrix\n                // so that we can determine the 2D basis for the splat. This is done using the method described\n                // here: https://people.math.harvard.edu/~knill/teaching/math21b2004/exhibits/2dmatrices/index.html\n                //\n                // This is a different approach than in the original work at INRIA. In that work they compute the\n                // max extents of the 2D covariance matrix in screen space to form an axis aligned bounding rectangle\n                // which forms the geometry that is actually rasterized. They then use the inverse 2D covariance\n                // matrix (called 'conic') to determine fragment opacity.\n                float a = cov2Dv.x;\n                float d = cov2Dv.z;\n                float b = cov2Dv.y;\n                float D = a * d - b * b;\n                float trace = a + d;\n                float traceOver2 = 0.5 * trace;\n                float term2 = sqrt(trace * trace / 4.0 - D);\n                float eigenValue1 = traceOver2 + term2;\n                float eigenValue2 = max(traceOver2 - term2, 0.00); // prevent negative eigen value\n\n                const float maxSplatSize = 1024.0;\n                vec2 eigenVector1 = normalize(vec2(b, eigenValue1 - a));\n                // since the eigen vectors are orthogonal, we derive the second one from the first\n                vec2 eigenVector2 = vec2(eigenVector1.y, -eigenVector1.x);\n                vec2 basisVector1 = eigenVector1 * min(sqrt(2.0 * eigenValue1), maxSplatSize);\n                vec2 basisVector2 = eigenVector2 * min(sqrt(2.0 * eigenValue2), maxSplatSize);\n\n                vec2 ndcOffset = vec2(vPosition.x * basisVector1 + vPosition.y * basisVector2) * basisViewport;\n\n                gl_Position = vec4(ndcCenter.xy + ndcOffset, ndcCenter.z, 1.0);\n            }",fragmentShader:"\n            precision highp float;\n            #include <common>\n\n            uniform vec3 debugColor;\n\n            varying vec4 vColor;\n            varying vec2 vUv;\n\n            varying vec2 vPosition;\n\n            void main () {\n                // compute the negative squared distance from the center of the splat to the\n                // current fragment in the splat's local space.\n                float A = -dot(vPosition, vPosition);\n                if (A < -4.0) discard;\n                vec3 color = vColor.rgb;\n                A = exp(A) * vColor.a;\n                gl_FragColor = vec4(color.rgb, A);\n            }",transparent:!0,alphaTest:1,blending:e.NormalBlending,depthTest:!0,depthWrite:!1,side:e.DoubleSide})}static buildGeomtery(t){const n=t.getSplatCount(),r=new e.BufferGeometry;r.setIndex([0,1,2,0,2,3]);const o=new Float32Array(12),s=new e.BufferAttribute(o,3);r.setAttribute("position",s),s.setXYZ(0,-1,-1,0),s.setXYZ(1,-1,1,0),s.setXYZ(2,1,1,0),s.setXYZ(3,1,-1,0),s.needsUpdate=!0;const i=(new e.InstancedBufferGeometry).copy(r),a=new Uint32Array(n),c=new e.InstancedBufferAttribute(a,1,!1);return c.setUsage(e.DynamicDrawUsage),i.setAttribute("splatIndex",c),i.instanceCount=n,i}buildSplatTree(){this.splatTree=new Q(10,500),console.time("SplatTree build");const t=new e.Vector4;this.splatTree.processSplatBuffer(this.splatBuffer,(e=>(this.splatBuffer.getColor(e,t),t.w>this.splatAlphaRemovalThreshold))),console.timeEnd("SplatTree build");let n=0,r=0,o=0,s=0;this.splatTree.visitLeaves((e=>{const t=e.data.indexes.length;t>0&&(r+=t,o=Math.max(o,t),s++,n++)})),console.log(`SplatTree leaves: ${this.splatTree.countLeaves()}`),console.log(`SplatTree leaves with splats:${n}`),r/=s,console.log(`Avg splat count per node: ${r}`)}getSplatTree(){return this.splatTree}resetLocalSplatDataAndTexturesFromSplatBuffer(){this.updateLocalSplatDataFromSplatBuffer(),this.allocateAndStoreLocalSplatDataInTextures(),this.enableDistancesComputationOnGPU&&this.updateCentersGPUBufferForDistancesComputation()}updateLocalSplatDataFromSplatBuffer(){const e=this.splatBuffer.getSplatCount();this.covariances=new Float32Array(6*e),this.colors=new Uint8Array(4*e),this.centers=new Float32Array(3*e),this.splatBuffer.fillCovarianceArray(this.covariances),this.splatBuffer.fillCenterArray(this.centers),this.splatBuffer.fillColorArray(this.colors)}allocateAndStoreLocalSplatDataInTextures(){const t=this.splatBuffer.getSplatCount(),n=new e.Vector2(4096,1024);for(;n.x*n.y*2<6*t;)n.y*=2;const r=new e.Vector2(4096,1024);for(;r.x*r.y*4<4*t;)r.y*=2;let o,s;if(this.halfPrecisionCovariancesOnGPU){s=new Uint16Array(n.x*n.y*2);for(let t=0;t<this.covariances.length;t++)s[t]=e.DataUtils.toHalfFloat(this.covariances[t]);o=new e.DataTexture(s,n.x,n.y,e.RGFormat,e.HalfFloatType)}else s=new Float32Array(n.x*n.y*2),s.set(this.covariances),o=new e.DataTexture(s,n.x,n.y,e.RGFormat,e.FloatType);o.needsUpdate=!0,this.material.uniforms.covariancesTexture.value=o,this.material.uniforms.covariancesTextureSize.value.copy(n);const i=new Uint32Array(r.x*r.y*4);for(let e=0;e<t;e++){const t=4*e,n=3*e,r=4*e;i[r]=(a=this.colors[t],c=this.colors[t+1],l=this.colors[t+2],h=this.colors[t+3],a+(c<<8)+(l<<16)+(h<<24)),i[r+1]=w(this.centers[n]),i[r+2]=w(this.centers[n+1]),i[r+3]=w(this.centers[n+2])}var a,c,l,h;const d=new e.DataTexture(i,r.x,r.y,e.RGBAIntegerFormat,e.UnsignedIntType);d.internalFormat="RGBA32UI",d.needsUpdate=!0,this.material.uniforms.centersColorsTexture.value=d,this.material.uniforms.centersColorsTextureSize.value.copy(r),this.material.uniformsNeedUpdate=!0,this.splatDataTextures={covariances:{data:s,texture:o,size:n},centerColors:{data:i,texture:d,size:r}}}updateSplatDataToDataTextures(){this.updateLocalCovarianceDataToDataTexture(),this.updateLocalCenterColorDataToDataTexture()}updateLocalCovarianceDataToDataTexture(){this.splatDataTextures.covariances.data.set(this.covariances),this.splatDataTextures.covariances.texture.needsUpdate=!0}updateLocalCenterColorDataToDataTexture(){this.splatDataTextures.centerColors.data.set(this.centerColors),this.splatDataTextures.centerColors.texture.needsUpdate=!0}updateIndexes(e,t){const n=this.geometry;n.attributes.splatIndex.set(e),n.attributes.splatIndex.needsUpdate=!0,n.instanceCount=t}updateUniforms=function(){const t=new e.Vector2;return function(e,n,r){this.splatBuffer.getSplatCount()>0&&(t.set(e.x*this.devicePixelRatio,e.y*this.devicePixelRatio),this.material.uniforms.viewport.value.copy(t),this.material.uniforms.basisViewport.value.set(2/t.x,2/t.y),this.material.uniforms.focal.value.set(n,r),this.material.uniformsNeedUpdate=!0)}}();getSplatDataTextures(){return this.splatDataTextures}getSplatCount(){return this.splatBuffer.getSplatCount()}getCenters(){return this.centers}getColors(){return this.colors}getCovariances(){return this.covariances}setupDistancesTransformFeedback(){const e=this.getSplatCount(),t=(e,t,n)=>{const r=e.createShader(t);if(!r)return console.error("Fatal error: gl could not create a shader object."),null;e.shaderSource(r,n),e.compileShader(r);if(!e.getShaderParameter(r,e.COMPILE_STATUS)){let n="unknown";t===e.VERTEX_SHADER?n="vertex shader":t===e.FRAGMENT_SHADER&&(n="fragement shader");const o=e.getShaderInfoLog(r);return console.error("Failed to compile "+n+" with these errors:"+o),e.deleteShader(r),null}return r},n=this.renderer.getContext(),r=n.getParameter(n.VERTEX_ARRAY_BINDING);this.distancesTransformFeedback.vao=n.createVertexArray(),n.bindVertexArray(this.distancesTransformFeedback.vao),this.distancesTransformFeedback.program=n.createProgram();const o=t(n,n.VERTEX_SHADER,"#version 300 es\n            in ivec3 center;\n            uniform ivec3 viewProj;\n            flat out int distance;\n            void main(void) {\n                distance = center.x * viewProj.x + center.y * viewProj.y + center.z * viewProj.z; \n            }\n        "),s=t(n,n.FRAGMENT_SHADER,"#version 300 es\n            precision lowp float;\n            out vec4 fragColor;\n            void main(){}\n        ");if(!o||!s)throw new Error("Could not compile shaders for distances computation on GPU.");n.attachShader(this.distancesTransformFeedback.program,o),n.attachShader(this.distancesTransformFeedback.program,s),n.transformFeedbackVaryings(this.distancesTransformFeedback.program,["distance"],n.SEPARATE_ATTRIBS),n.linkProgram(this.distancesTransformFeedback.program);if(!n.getProgramParameter(this.distancesTransformFeedback.program,n.LINK_STATUS)){const e=n.getProgramInfoLog(program);throw console.error("Fatal error: Failed to link program: "+e),n.deleteProgram(this.distancesTransformFeedback.program),n.deleteShader(s),n.deleteShader(o),new Error("Could not link shaders for distances computation on GPU.")}n.useProgram(this.distancesTransformFeedback.program),this.distancesTransformFeedback.centersLoc=n.getAttribLocation(this.distancesTransformFeedback.program,"center"),this.distancesTransformFeedback.viewProjLoc=n.getUniformLocation(this.distancesTransformFeedback.program,"viewProj"),this.distancesTransformFeedback.centersBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),n.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),n.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,3,n.INT,0,0),this.distancesTransformFeedback.outDistancesBuffer=n.createBuffer(),n.bindBuffer(n.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),n.bufferData(n.ARRAY_BUFFER,4*e,n.DYNAMIC_DRAW),this.distancesTransformFeedback.id=n.createTransformFeedback(),n.bindTransformFeedback(n.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),n.bindBufferBase(n.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),r&&n.bindVertexArray(r)}getIntegerCenters(e){const t=this.getSplatCount(),n=new Float32Array(this.centers);let r,o=e?4:3;r=new Int32Array(t*o);for(let s=0;s<t;s++){for(let e=0;e<3;e++)r[s*o+e]=Math.round(1e3*n[3*s+e]);e&&(r[s*o+3]=1)}return r}getIntegerMatrixArray(e){const t=e.elements,n=[];for(let e=0;e<16;e++)n[e]=Math.round(1e3*t[e]);return n}updateCentersGPUBufferForDistancesComputation(){const e=this.renderer.getContext(),t=e.getParameter(e.VERTEX_ARRAY_BINDING);e.bindVertexArray(this.distancesTransformFeedback.vao);const n=this.getIntegerCenters(!1);e.bindBuffer(e.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),e.bufferData(e.ARRAY_BUFFER,n,e.STATIC_DRAW),t&&e.bindVertexArray(t)}computeDistancesOnGPU(e,t){const n=this.getIntegerMatrixArray(e),r=[n[2],n[6],n[10]],o=this.renderer.getContext(),s=o.getParameter(o.VERTEX_ARRAY_BINDING),i=o.getParameter(o.CURRENT_PROGRAM);o.bindVertexArray(this.distancesTransformFeedback.vao),o.useProgram(this.distancesTransformFeedback.program),o.enable(o.RASTERIZER_DISCARD),o.uniform3i(this.distancesTransformFeedback.viewProjLoc,r[0],r[1],r[2]),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.centersBuffer),o.enableVertexAttribArray(this.distancesTransformFeedback.centersLoc),o.vertexAttribIPointer(this.distancesTransformFeedback.centersLoc,3,o.INT,0,0),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,this.distancesTransformFeedback.id),o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER,0,this.distancesTransformFeedback.outDistancesBuffer),o.beginTransformFeedback(o.POINTS),o.drawArrays(o.POINTS,0,this.getSplatCount()),o.endTransformFeedback(),o.bindBufferBase(o.TRANSFORM_FEEDBACK_BUFFER,0,null),o.bindTransformFeedback(o.TRANSFORM_FEEDBACK,null),o.bindBuffer(o.ARRAY_BUFFER,this.distancesTransformFeedback.outDistancesBuffer),o.getBufferSubData(o.ARRAY_BUFFER,0,t),o.bindBuffer(o.ARRAY_BUFFER,null),o.disable(o.RASTERIZER_DISCARD),i&&o.useProgram(i),s&&o.bindVertexArray(s)}}class K{static DepthMapRange=65536;static MemoryPageSize=65536;static BytesPerFloat=4;static BytesPerInt=4}function X(e){let t,n,r,o,s,i,a,c,l,h,d,u;e.onmessage=p=>{if(p.data.centers)centers=p.data.centers,new Int32Array(n,l,4*r).set(new Int32Array(centers)),e.postMessage({sortSetupComplete:!0});else if(p.data.sort){const m=p.data.sort.splatRenderCount||0;!function(p,m,f,y){const g=performance.now();d||(d=new Uint32Array(u.DepthMapRange)),new Int32Array(n,h,16).set(f),new Uint32Array(n,c,u.DepthMapRange).set(d),t.exports.sortIndexes(o,l,i,a,c,h,s,u.DepthMapRange,p,m,r,y);const A=performance.now();e.postMessage({sortDone:!0,splatSortCount:p,splatRenderCount:m,sortTime:A-g})}(p.data.sort.splatSortCount||0,m,p.data.sort.viewProj,p.data.sort.usePrecomputedDistances)}else if(p.data.init){u=p.data.init.Constants,r=p.data.init.splatCount;const d=4*u.BytesPerInt,m=new Uint8Array(p.data.init.sorterWasmBytes),f=r*u.BytesPerInt,y=r*d,g=16*u.BytesPerFloat,A=r*u.BytesPerInt,C=r*u.BytesPerInt,w=r*u.BytesPerInt,v=u.DepthMapRange*u.BytesPerInt*2,x=32*u.MemoryPageSize,b=f+y+g+A+C+w+v+x,M=Math.floor(b/u.MemoryPageSize)+1,P={module:{},env:{memory:new WebAssembly.Memory({initial:2*M,maximum:4*M,shared:!0})}};WebAssembly.compile(m).then((e=>WebAssembly.instantiate(e,P))).then((r=>{t=r,o=0,l=o+f,h=l+y,i=h+g,a=i+A,c=a+C,s=c+v,n=P.env.memory.buffer,e.postMessage({sortSetupPhase1Complete:!0,indexesToSortBuffer:n,indexesToSortOffset:o,sortedIndexesBuffer:n,sortedIndexesOffset:s,precomputedDistancesBuffer:n,precomputedDistancesOffset:i})}))}}}class ${constructor(t={}){t.cameraUp||(t.cameraUp=[0,1,0]),t.initialCameraPosition||(t.initialCameraPosition=[0,10,15]),t.initialCameraLookAt||(t.initialCameraLookAt=[0,0,0]),void 0===t.selfDrivenMode&&(t.selfDrivenMode=!0),void 0===t.useBuiltInControls&&(t.useBuiltInControls=!0),this.rootElement=t.rootElement,this.usingExternalCamera=!!t.camera,this.usingExternalRenderer=!!t.renderer,this.cameraUp=(new e.Vector3).fromArray(t.cameraUp),this.initialCameraPosition=(new e.Vector3).fromArray(t.initialCameraPosition),this.initialCameraLookAt=(new e.Vector3).fromArray(t.initialCameraLookAt),this.scene=t.scene,this.renderer=t.renderer,this.camera=t.camera,this.useBuiltInControls=t.useBuiltInControls,this.controls=null,this.ignoreDevicePixelRatio=t.ignoreDevicePixelRatio||!1,this.devicePixelRatio=this.ignoreDevicePixelRatio?1:window.devicePixelRatio,this.selfDrivenMode=t.selfDrivenMode,this.selfDrivenUpdateFunc=this.selfDrivenUpdate.bind(this),this.gpuAcceleratedSort=t.gpuAcceleratedSort,!0!==this.gpuAcceleratedSort&&!1!==this.gpuAcceleratedSort&&(this.gpuAcceleratedSort=!0),this.showMeshCursor=!1,this.showControlPlane=!1,this.showInfo=!1,this.sceneHelper=null,this.sortWorker=null,this.sortRunning=!1,this.splatRenderCount=0,this.sortWorkerIndexesToSort=null,this.sortWorkerSortedIndexes=null,this.sortWorkerPrecomputedDistances=null,this.splatMesh=null,this.selfDrivenModeRunning=!1,this.splatRenderingInitialized=!1,this.raycaster=new H,this.infoPanel=null,this.infoPanelCells={},this.currentFPS=0,this.lastSortTime=0,this.previousCameraTarget=new e.Vector3,this.nextCameraTarget=new e.Vector3,this.mousePosition=new e.Vector2,this.mouseDownPosition=new e.Vector2,this.mouseDownTime=null,this.initialized=!1,this.init()}init(){if(this.initialized)return;this.rootElement||this.usingExternalRenderer||(this.rootElement=document.createElement("div"),this.rootElement.style.width="100%",this.rootElement.style.height="100%",document.body.appendChild(this.rootElement));const t=new e.Vector2;if(this.getRenderDimensions(t),this.usingExternalCamera||(this.camera=new e.PerspectiveCamera(50,t.x/t.y,.1,500),this.camera.position.copy(this.initialCameraPosition),this.camera.lookAt(this.initialCameraLookAt),this.camera.up.copy(this.cameraUp).normalize()),this.usingExternalRenderer||(this.renderer=new e.WebGLRenderer({antialias:!1,precision:"highp"}),this.renderer.setPixelRatio(this.devicePixelRatio),this.renderer.autoClear=!0,this.renderer.setClearColor(0,0,0,0),this.renderer.setSize(t.x,t.y)),this.scene=this.scene||new e.Scene,this.sceneHelper=new V(this.scene),this.sceneHelper.setupMeshCursor(),this.sceneHelper.setupFocusMarker(),this.sceneHelper.setupControlPlane(),this.useBuiltInControls&&(this.controls=new k(this.camera,this.renderer.domElement),this.controls.listenToKeyEvents(window),this.controls.rotateSpeed=.5,this.controls.maxPolarAngle=.75*Math.PI,this.controls.minPolarAngle=.1,this.controls.enableDamping=!0,this.controls.dampingFactor=.05,this.controls.target.copy(this.initialCameraLookAt),this.rootElement.addEventListener("pointermove",this.onMouseMove.bind(this),!1),this.rootElement.addEventListener("pointerdown",this.onMouseDown.bind(this),!1),this.rootElement.addEventListener("pointerup",this.onMouseUp.bind(this),!1),window.addEventListener("keydown",this.onKeyDown.bind(this),!1)),!this.usingExternalRenderer){new ResizeObserver((()=>{this.getRenderDimensions(t),this.renderer.setSize(t.x,t.y)})).observe(this.rootElement),this.rootElement.appendChild(this.renderer.domElement)}this.setupInfoPanel(),this.loadingSpinner=new L(null,this.rootElement),this.loadingSpinner.hide(),this.initialized=!0}onKeyDown=function(){const t=new e.Vector3,n=new e.Matrix4,r=new e.Matrix4;return function(e){switch(t.set(0,0,-1),t.transformDirection(this.camera.matrixWorld),n.makeRotationAxis(t,Math.PI/128),r.makeRotationAxis(t,-Math.PI/128),e.code){case"ArrowLeft":this.camera.up.transformDirection(n);break;case"ArrowRight":this.camera.up.transformDirection(r);break;case"KeyC":this.showMeshCursor=!this.showMeshCursor;break;case"KeyP":this.showControlPlane=!this.showControlPlane;break;case"KeyI":this.showInfo=!this.showInfo,this.showInfo?this.infoPanel.style.display="block":this.infoPanel.style.display="none"}}}();onMouseMove(e){this.mousePosition.set(e.offsetX,e.offsetY)}onMouseDown(){this.mouseDownPosition.copy(this.mousePosition),this.mouseDownTime=b()}onMouseUp=function(){const t=new e.Vector2,n=new e.Vector2,r=new e.Vector3,o=[];return function(e){n.copy(this.mousePosition).sub(this.mouseDownPosition);const s=b()-this.mouseDownTime<.5&&n.length()<2;if(!this.transitioningCameraTarget&&s&&(this.getRenderDimensions(t),o.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,t),this.mousePosition.set(e.offsetX,e.offsetY),this.raycaster.intersectSplatMesh(this.splatMesh,o),o.length>0)){const e=o[0].origin;r.copy(e).sub(this.camera.position),r.length()>.75&&(this.previousCameraTarget.copy(this.controls.target),this.nextCameraTarget.copy(e),this.transitioningCameraTarget=!0,this.transitioningCameraTargetStartTime=b())}}}();getRenderDimensions(e){this.rootElement?(e.x=this.rootElement.offsetWidth,e.y=this.rootElement.offsetHeight):this.renderer.getSize(e)}setupInfoPanel(){this.infoPanel=document.createElement("div"),this.infoPanel.style.position="absolute",this.infoPanel.style.padding="10px",this.infoPanel.style.backgroundColor="#cccccc",this.infoPanel.style.border="#aaaaaa 1px solid",this.infoPanel.style.zIndex=100,this.infoPanel.style.width="375px",this.infoPanel.style.fontFamily="arial",this.infoPanel.style.fontSize="10pt",this.infoPanel.style.textAlign="left";const e=[["Camera position","cameraPosition"],["Camera look-at","cameraLookAt"],["Camera up","cameraUp"],["Cursor position","cursorPosition"],["FPS","fps"],["Render window","renderWindow"],["Rendering:","renderSplatCount"],["Sort time","sortTime"]],t=document.createElement("div");t.style.display="table";for(let n of e){const e=document.createElement("div");e.style.display="table-row";const r=document.createElement("div");r.style.display="table-cell",r.style.width="110px",r.innerHTML=`${n[0]}: `;const o=document.createElement("div");o.style.display="table-cell",o.style.width="10px",o.innerHTML=" ";const s=document.createElement("div");s.style.display="table-cell",s.innerHTML="",this.infoPanelCells[n[1]]=s,e.appendChild(r),e.appendChild(o),e.appendChild(s),t.appendChild(e)}this.infoPanel.appendChild(t),this.infoPanel.style.display="none",this.renderer.domElement.parentElement.prepend(this.infoPanel)}updateSplatMeshUniforms=function(){const t=new e.Vector2;return function(){this.splatMesh.getSplatCount()>0&&(this.getRenderDimensions(t),this.cameraFocalLengthX=this.camera.projectionMatrix.elements[0]*this.devicePixelRatio*t.x*.45,this.cameraFocalLengthY=this.camera.projectionMatrix.elements[5]*this.devicePixelRatio*t.y*.45,this.splatMesh.updateUniforms(t,this.cameraFocalLengthX,this.cameraFocalLengthY))}}();loadFile(t,n={}){n.position&&(n.position=(new e.Vector3).fromArray(n.position)),n.orientation&&(n.orientation=(new e.Quaternion).fromArray(n.orientation)),n.splatAlphaRemovalThreshold=n.splatAlphaRemovalThreshold||1,n.halfPrecisionCovariancesOnGPU=!!n.halfPrecisionCovariancesOnGPU,!1!==n.showLoadingSpinner&&(n.showLoadingSpinner=!0),n.showLoadingSpinner&&this.loadingSpinner.show();const r=(e,t)=>{if(n.showLoadingSpinner)if(100==e)this.loadingSpinner.setMessage("Download complete!");else{const e=t?`: ${t}`:"...";this.loadingSpinner.setMessage(`Downloading${e}`)}n.onProgress&&n.onProgress(e,t,"downloading")};return new Promise(((e,o)=>{let s;t.endsWith(".splat")?s=(new T).loadFromURL(t,r):t.endsWith(".ply")?s=(new S).loadFromURL(t,r,0,n.splatAlphaRemovalThreshold):o(new Error(`Viewer::loadFile -> File format not supported: ${t}`)),s.then((t=>{n.showLoadingSpinner&&this.loadingSpinner.hide(),n.onProgress&&n.onProgress(0,"0%","processing"),this.loadSplatBuffer(t,n).then((()=>{n.onProgress&&n.onProgress(100,"100%","processing"),e()}))})).catch((e=>{o(new Error(`Viewer::loadFile -> Could not load file ${t}`))}))}))}loadSplatBuffer(e,t){return!1!==t.showLoadingSpinner&&(t.showLoadingSpinner=!0),new Promise((n=>{t.showLoadingSpinner&&(this.loadingSpinner.show(),this.loadingSpinner.setMessage("Processing splats...")),window.setTimeout((()=>{this.setupSplatMesh(e,t.splatAlphaRemovalThreshold,t.position,t.orientation,t.halfPrecisionCovariancesOnGPU,this.devicePixelRatio,this.gpuAcceleratedSort),this.setupSortWorker(e).then((()=>{t.showLoadingSpinner&&this.loadingSpinner.hide(),n()}))}),1)}))}setupSplatMesh(t,n=1,r=new e.Vector3,o=new e.Quaternion,s=!1,i=1,a=!0){const c=t.getSplatCount();console.log(`Splat count: ${c}`),this.splatMesh=G.buildMesh(t,this.renderer,n,s,i,a),this.splatMesh.position.copy(r),this.splatMesh.quaternion.copy(o),this.splatMesh.frustumCulled=!1,this.updateSplatMeshUniforms(),this.splatRenderCount=c}setupSortWorker(e){return new Promise((t=>{const n=e.getSplatCount();this.sortWorker=function(e){const t=new Worker(URL.createObjectURL(new Blob(["(",X.toString(),")(self)"],{type:"application/javascript"}))),n=atob("AGFzbQEAAAAADAZkeWxpbmsAAAAAAAEXA2AAAGAMf39/f39/f39/f39/AGAAAX8CEgEDZW52Bm1lbW9yeQIDAICABAMEAwABAgc5AxFfX3dhc21fY2FsbF9jdG9ycwAAC3NvcnRJbmRleGVzAAETZW1zY3JpcHRlbl90bHNfaW5pdAACCtUEAwMAAQvJBAICewJ9IAkgCGshCgJAIAsEQEH4////ByELQYiAgIB4IQggCSAKTQ0BIAohBQNAIAMgBUECdCIBaiACIAAgAWooAgBBAnRqKAIAIgE2AgAgASALIAEgC0gbIQsgASAIIAEgCEobIQggBUEBaiIFIAlHDQALDAELQfj///8HIQtBiICAgHghCCAJIApNDQAgBUEoaiAFQRhqIAX9CQII/VYCAAH9VgIAAiENIAohBQNAIAMgBUECdCICaiABIAAgAmooAgBBBHRq/QAAACAN/bUBIgz9GwAgDP0bAWogDP0bAmoiAjYCACACIAsgAiALSBshCyACIAggAiAIShshCCAFQQFqIgUgCUcNAAsLIAkgCksEQCAHQQFrsyAIsiALspOVIQ4gCiEIA0ACfyAOIAMgCEECdGoiASgCACALa7KUIg+LQwAAAE9dBEAgD6gMAQtBgICAgHgLIQUgASAFNgIAIAQgBUECdGoiASABKAIAQQFqNgIAIAhBAWoiCCAJRw0ACwsgB0ECTwRAIAQoAgAhCEEBIQsDQCAEIAtBAnRqIgEgASgCACAIaiIINgIAIAtBAWoiCyAHRw0ACwsgCkEASgRAIAohCwNAIAYgC0EBayIBQQJ0IgJqIAAgAmooAgA2AgAgC0EBSiECIAEhCyACDQALCyAJIApKBEAgCSELA0AgBiAJIAQgAyALQQFrIgtBAnQiAWooAgBBAnRqIgIoAgAiBWtBAnRqIAAgAWooAgA2AgAgAiAFQQFrNgIAIAogC0gNAAsLCwQAQQAL"),r=new Uint8Array(n.length);for(let e=0;e<n.length;e++)r[e]=n.charCodeAt(e);return t.postMessage({init:{sorterWasmBytes:r.buffer,splatCount:e,Constants:{BytesPerFloat:K.BytesPerFloat,BytesPerInt:K.BytesPerInt,DepthMapRange:K.DepthMapRange,MemoryPageSize:K.MemoryPageSize}}}),t}(n),this.sortWorker.onmessage=r=>{if(r.data.sortDone)this.sortRunning=!1,this.splatMesh.updateIndexes(this.sortWorkerSortedIndexes,r.data.splatRenderCount),this.lastSortTime=r.data.sortTime;else if(r.data.sortCanceled)this.sortRunning=!1;else if(r.data.sortSetupPhase1Complete){console.log("Sorting web worker WASM setup complete."),this.sortWorker.postMessage({centers:this.splatMesh.getIntegerCenters(!0).buffer}),this.sortWorkerSortedIndexes=new Uint32Array(r.data.sortedIndexesBuffer,r.data.sortedIndexesOffset,e.getSplatCount()),this.sortWorkerIndexesToSort=new Uint32Array(r.data.indexesToSortBuffer,r.data.indexesToSortOffset,e.getSplatCount()),this.sortWorkerPrecomputedDistances=new Int32Array(r.data.precomputedDistancesBuffer,r.data.precomputedDistancesOffset,e.getSplatCount());for(let e=0;e<n;e++)this.sortWorkerIndexesToSort[e]=e}else if(r.data.sortSetupComplete){console.log("Sorting web worker ready."),this.splatMesh.updateIndexes(this.sortWorkerSortedIndexes,e.getSplatCount());const n=this.splatMesh.getSplatDataTextures(),r=n.covariances.size,o=n.centerColors.size;console.log("Covariances texture size: "+r.x+" x "+r.y),console.log("Centers/colors texture size: "+o.x+" x "+o.y),this.updateView(!0,!0),this.splatRenderingInitialized=!0,t()}}}))}gatherSceneNodes=function(){const t=[],n=new e.Vector3,r=new e.Vector3,o=new e.Vector3,s=new e.Matrix4,i=new e.Vector3,a=new e.Vector3(0,0,-1),c=new e.Vector3,l=e=>c.copy(e.max).sub(e.min).length();return function(c){this.getRenderDimensions(i);const h=i.y/2/Math.tan(this.camera.fov/2*e.MathUtils.DEG2RAD),d=Math.atan(i.x/2/h),u=Math.atan(i.y/2/h),p=Math.cos(d),m=Math.cos(u);s.copy(this.camera.matrixWorld).invert(),s.multiply(this.splatMesh.matrixWorld);const f=this.splatMesh.getSplatTree();let y=0,g=0;const A=f.nodesWithIndexes.length;for(let e=0;e<A;e++){const i=f.nodesWithIndexes[e];o.copy(i.center).applyMatrix4(s);const h=o.length();o.normalize(),n.copy(o).setX(0).normalize(),r.copy(o).setY(0).normalize();const d=a.dot(r),u=a.dot(n),A=l(i);!c&&(d<p-.6||u<m-.6||h>125)&&h>A||(g+=i.data.indexes.length,t[y]=i,i.data.distanceToNode=h,y++)}t.length=y,t.sort(((e,t)=>e.data.distanceToNode<t.data.distanceToNode?-1:1)),this.splatRenderCount=g;let C=g*K.BytesPerInt;for(let e=0;e<y;e++){const n=t[e],r=n.data.indexes.length,o=r*K.BytesPerInt;new Uint32Array(this.sortWorkerIndexesToSort.buffer,C-o,r).set(n.data.indexes),C-=o}}}();start(){if(!this.selfDrivenMode)throw new Error("Cannot start viewer unless it is in self driven mode.");requestAnimationFrame(this.selfDrivenUpdateFunc),this.selfDrivenModeRunning=!0}stop(){this.selfDrivenMode&&this.selfDrivenModeRunning&&(cancelAnimationFrame(),this.selfDrivenModeRunning=!1)}updateFPS=function(){let e=b(),t=0;return function(){const n=b();n-e>=1?(this.currentFPS=t,t=0,e=n):t++}}();updateForRendererSizeChanges=function(){const t=new e.Vector2,n=new e.Vector2;return function(){this.renderer.getSize(n),n.x===t.x&&n.y===t.y||(this.usingExternalCamera||(this.camera.aspect=n.x/n.y,this.camera.updateProjectionMatrix()),this.splatRenderingInitialized&&this.updateSplatMeshUniforms(),t.copy(n))}}();selfDrivenUpdate(){this.selfDrivenMode&&requestAnimationFrame(this.selfDrivenUpdateFunc),this.update(),this.render()}update(){this.controls&&this.controls.update(),this.updateView(),this.updateForRendererSizeChanges(),this.updateMeshCursor(),this.updateFPS(),this.timingSensitiveUpdates(),this.updateInfo(),this.updateControlPlane()}timingSensitiveUpdates=function(){let e;return function(){const t=b();e||(e=t);const n=t-e;this.updateCameraTransition(t),this.updateFocusMarker(n),e=t}}();updateCameraTransition=function(){let t=new e.Vector3,n=new e.Vector3,r=new e.Vector3;return function(e){if(this.transitioningCameraTarget){n.copy(this.previousCameraTarget).sub(this.camera.position).normalize(),r.copy(this.nextCameraTarget).sub(this.camera.position).normalize();const o=Math.acos(n.dot(r)),s=(o/(Math.PI/3)*.65+.3)/o*(e-this.transitioningCameraTargetStartTime);t.copy(this.previousCameraTarget).lerp(this.nextCameraTarget,s),this.camera.lookAt(t),this.controls.target.copy(t),s>=1&&(this.transitioningCameraTarget=!1)}}}();updateFocusMarker=function(){const t=new e.Vector2;let n=!1;return function(e){this.getRenderDimensions(t);if(this.transitioningCameraTarget){this.sceneHelper.setFocusMarkerVisibility(!0);const r=Math.max(this.sceneHelper.getFocusMarkerOpacity(),0);let o=Math.min(r+10*e,1);this.sceneHelper.setFocusMarkerOpacity(o),this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,t),n=!0}else{let r;if(r=n?1:Math.min(this.sceneHelper.getFocusMarkerOpacity(),1),r>0){this.sceneHelper.updateFocusMarker(this.nextCameraTarget,this.camera,t);let n=Math.max(r-2.5*e,0);this.sceneHelper.setFocusMarkerOpacity(n),0===n&&this.sceneHelper.setFocusMarkerVisibility(!1)}n=!1}}}();updateMeshCursor=function(){const t=[],n=new e.Vector2;return function(){this.showMeshCursor?(this.getRenderDimensions(n),t.length=0,this.raycaster.setFromCameraAndScreenPosition(this.camera,this.mousePosition,n),this.raycaster.intersectSplatMesh(this.splatMesh,t),t.length>0?(this.sceneHelper.setMeshCursorVisibility(!0),this.sceneHelper.positionAndOrientMeshCursor(t[0].origin,this.camera)):this.sceneHelper.setMeshCursorVisibility(!1)):this.sceneHelper.setMeshCursorVisibility(!1)}}();updateInfo=function(){const t=new e.Vector2;return function(){if(this.showInfo){const e=this.splatMesh.getSplatCount();this.getRenderDimensions(t);const n=this.camera.position,r=`[${n.x.toFixed(5)}, ${n.y.toFixed(5)}, ${n.z.toFixed(5)}]`;this.infoPanelCells.cameraPosition.innerHTML=r;const o=this.controls.target,s=`[${o.x.toFixed(5)}, ${o.y.toFixed(5)}, ${o.z.toFixed(5)}]`;this.infoPanelCells.cameraLookAt.innerHTML=s;const i=this.camera.up,a=`[${i.x.toFixed(5)}, ${i.y.toFixed(5)}, ${i.z.toFixed(5)}]`;if(this.infoPanelCells.cameraUp.innerHTML=a,this.showMeshCursor){const e=this.sceneHelper.meshCursor.position,t=`[${e.x.toFixed(5)}, ${e.y.toFixed(5)}, ${e.z.toFixed(5)}]`;this.infoPanelCells.cursorPosition.innerHTML=t}else this.infoPanelCells.cursorPosition.innerHTML="N/A";this.infoPanelCells.fps.innerHTML=this.currentFPS,this.infoPanelCells.renderWindow.innerHTML=`${t.x} x ${t.y}`;const c=this.splatRenderCount/e*100;this.infoPanelCells.renderSplatCount.innerHTML=`${this.splatRenderCount} splats out of ${e} (${c.toFixed(2)}%)`,this.infoPanelCells.sortTime.innerHTML=`${this.lastSortTime.toFixed(3)} ms`}}}();updateControlPlane(){this.showControlPlane?(this.sceneHelper.setControlPlaneVisibility(!0),this.sceneHelper.positionAndOrientControlPlane(this.controls.target,this.camera.up)):this.sceneHelper.setControlPlaneVisibility(!1)}render=function(){const e=this.renderer.autoClear;this.renderer.autoClear=!1,(e=>{for(let t of e.children)if(t.visible)return!0;return!1})(this.scene)&&this.renderer.render(this.scene,this.camera),this.renderer.render(this.splatMesh,this.camera),this.sceneHelper.getFocusMarkerOpacity()>0&&this.renderer.render(this.sceneHelper.focusMarker,this.camera),this.showControlPlane&&this.renderer.render(this.sceneHelper.controlPlane,this.camera),this.renderer.autoClear=e};updateView=function(){const t=new e.Matrix4,n=[],r=new e.Vector3(0,0,-1),o=new e.Vector3(0,0,-1),s=new e.Vector3,i=new e.Vector3,a=[],c=[{angleThreshold:.55,sortFractions:[.125,.33333,.75]},{angleThreshold:.65,sortFractions:[.33333,.66667]},{angleThreshold:.8,sortFractions:[.5]}];return function(e=!1,l=!1){let h=0,d=0;o.set(0,0,-1).applyQuaternion(this.camera.quaternion);let u=!1,p=!1;if(h=o.dot(r),d=i.copy(this.camera.position).sub(s).length(),(e||0!==a.length||(h<=.95&&(u=!0),d>=1&&(p=!0),u||p))&&(t.copy(this.camera.matrixWorld).invert(),t.premultiply(this.camera.projectionMatrix),t.multiply(this.splatMesh.matrixWorld),n[0]=this.camera.position.x,n[1]=this.camera.position.y,n[2]=this.camera.position.z,!this.sortRunning)){let e;if(this.sortRunning=!0,this.gatherSceneNodes(l),this.gpuAcceleratedSort&&(a.length<=1||a.length%2==0)&&this.splatMesh.computeDistancesOnGPU(t,this.sortWorkerPrecomputedDistances),0===a.length){for(let e of c)if(h<e.angleThreshold){for(let t of e.sortFractions)a.push(Math.floor(this.splatRenderCount*t));break}a.push(this.splatRenderCount)}e=Math.min(a.shift(),this.splatRenderCount),this.sortWorker.postMessage({sort:{viewProj:this.splatMesh.getIntegerMatrixArray(t),cameraPosition:n,splatRenderCount:this.splatRenderCount,splatSortCount:e,usePrecomputedDistances:this.gpuAcceleratedSort}}),0===a.length&&(s.copy(this.camera.position),r.copy(o))}}}();getSplatMesh(){return this.splatMesh}}export{S as PlyLoader,P as PlyParser,C as SplatBuffer,T as SplatLoader,$ as Viewer};
//# sourceMappingURL=gaussian-splats-3d.module.min.js.map
